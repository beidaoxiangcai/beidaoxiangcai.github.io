<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker 命令一条龙</title>
    <link href="/2023/01/14/&#39;Docker%20%E5%91%BD%E4%BB%A4%E4%B8%80%E6%9D%A1%E9%BE%99/"/>
    <url>/2023/01/14/&#39;Docker%20%E5%91%BD%E4%BB%A4%E4%B8%80%E6%9D%A1%E9%BE%99/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-命令一条龙"><a href="#Docker-命令一条龙" class="headerlink" title="Docker 命令一条龙"></a>Docker 命令一条龙</h1><p>Docker是一种容器化技术，可以将应用程序和所有相关的依赖项打包在一个容器中，使得应用程序可以在任何环境中轻松地运行。Docker可以提高应用程序的可移植性和可靠性，并简化应用程序的部署和维护。</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>Docker支持Windows、Linux和MacOS等操作系统，具体安装步骤可以参考Docker官方文档。</p><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><p>在安装完成Docker之后，我们就可以开始使用Docker命令了。Docker命令可以在终端中执行，用于构建、运行和管理Docker容器。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>构建镜像是Docker的核心功能之一，它允许我们将应用程序和所有相关的依赖项打包在一个容器中。下面是构建镜像的基本步骤：</p><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><p>在开始构建镜像之前，我们需要编写一个Dockerfile，用于描述应用程序的构建和运行过程。<br>Dockerfile是一个文本文件，包含了一系列的指令，用于指导Docker如何构建镜像。下面是一个简单的Dockerfile示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指定基础镜像</span><br>FROM ubuntu:latest<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置工作目录</span><br>WORKDIR /app<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝应用程序到容器中</span><br>COPY . /app<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装依赖项</span><br>RUN apt-get update &amp;&amp; apt-get install -y python3<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置容器默认命令</span><br>CMD [&quot;python3&quot;, &quot;hello.py&quot;]<br></code></pre></td></tr></table></figure><p>在这个Dockerfile中，我们指定了基础镜像为最新版本的Ubuntu，设置了工作目录为&#x2F;app，拷贝应用程序到容器中，安装了Python3，并设置了容器的默认命令为python3 hello.py。 其中hello.py 脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="构建镜像-1"><a href="#构建镜像-1" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>在编写完Dockerfile之后，我们就可以使用docker build命令来构建镜像了。下面是一个简单的构建镜像的命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t hello .<br></code></pre></td></tr></table></figure><p>在这个命令中，我们使用了-t参数来指定镜像的名称为hello，使用了.来表示当前目录下的Dockerfile。构建镜像的过程可能需要一些时间，取决于你的应用程序和基础镜像的大小和复杂性。</p><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><p>运行容器是Docker的另一个核心功能，它允许我们在Docker容器中运行应用程序。下面是运行容器的基本步骤：</p><ol><li>拉取镜像<br>在运行容器之前，我们需要拉取已经构建好的镜像。可以使用docker pull命令来拉取镜像，例如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --rm ubuntu:latest<br></code></pre></td></tr></table></figure></li><li>运行容器<br>在拉取完镜像之后，我们就可以使用docker run命令来运行容器了。下面是一个简单的运行容器的命令示例：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --rm ubuntu:latest<br></code></pre></td></tr></table></figure><p>在这个命令中，我们使用了-it参数来指定容器的交互模式，–rm参数表示容器退出后会自动删除，ubuntu:latest表示使用最新版本的Ubuntu镜像来运行容器。运行容器后，你将会进入一个类似于终端的界面，可以在其中运行命令。</p><ol start="3"><li>停止容器<br>在容器运行结束后，我们可以使用docker stop命令来停止容器，例如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop &lt;container_id&gt;<br></code></pre></td></tr></table></figure>其中，<container_id>是容器的ID，可以使用docker ps命令来查看容器的ID。</li></ol><h3 id="查看镜像和容器"><a href="#查看镜像和容器" class="headerlink" title="查看镜像和容器"></a>查看镜像和容器</h3><p>在使用Docker时，经常需要查看已经构建好的镜像和运行中的容器。可以使用docker images命令来查看已经构建好的镜像，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker images<br></code></pre></td></tr></table></figure><p>这个命令将会列出所有已经构建好的镜像，包括镜像的名称、标签、大小等信息。</p><p>可以使用docker ps命令来查看运行中的容器，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker ps<br></code></pre></td></tr></table></figure><p>这个命令将会列出所有运行中的容器，包括容器的ID、名称、状态等信息。如果需要查看已经停止的容器，可以使用docker ps -a命令。</p><h3 id="删除镜像和容器"><a href="#删除镜像和容器" class="headerlink" title="删除镜像和容器"></a>删除镜像和容器</h3><p>在使用Docker时，经常需要删除已经构建好的镜像和已经停止的容器。可以使用docker rmi命令来删除镜像，例如：\</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rmi &lt;image_name&gt;<br></code></pre></td></tr></table></figure><p>其中，<image_name>是镜像的名称，可以使用docker images命令来查看镜像的名称。</p><p>可以使用docker rm命令来删除容器，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm &lt;container_id&gt;<br></code></pre></td></tr></table></figure><p>其中，<container_id>是容器的ID，可以使用docker ps命令来查看容器的ID。</p><p>⚠ <strong>Note</strong>: 转载请注明出处</p>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 线程池的实现</title>
    <link href="/2022/10/23/C++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/10/23/C++%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C-线程池的实现"><a href="#C-线程池的实现" class="headerlink" title="C++ 线程池的实现"></a>C++ 线程池的实现</h1><ul><li>在并发编程中，使用多线程可以提高程序的执行效率。然而，手动管理线程可能会导致代码复杂和出错的风险，因此可以使用线程池来简化线程管理；</li><li>线程池通过预先创建一定数量的线程，将任务分配给这些线程执行，从而提高程序的并发性和响应速度；</li><li>线程池包括一个任务队列和一组工作线程，任务队列用于存储待执行的任务，工作线程则从任务队列中取出任务并执行。</li></ul><h2 id="任务队列实现-🔎"><a href="#任务队列实现-🔎" class="headerlink" title="任务队列实现 🔎"></a>任务队列实现 🔎</h2><p> 任务队列要同时从多个用户中接收用于待执行的任务，因此要保证线程安全。这里可以使用STL中的队列或链表来实现，同时用一个互斥量来保证队列的线程安全，并使用条件变量来实现阻塞式的队列操作。任务队列的代码实现如下：</p><p> 线程安全是通过 std::mutex 和 std::condition_variable 实现的。其中，push() 函数用于向队列中添加元素，try_pop() 函数用于尝试弹出队首元素，wait_and_pop() 函数用于等待队列非空并弹出队首元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadSafeQueue</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        m_queue.<span class="hljs-built_in">push</span>(value);<br>        m_cv.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T&amp;&amp; value)</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        m_queue.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">move</span>(value));<br>        m_cv.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_pop</span><span class="hljs-params">(T&amp; value)</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        <span class="hljs-keyword">if</span> (m_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        value = std::<span class="hljs-built_in">move</span>(m_queue.<span class="hljs-built_in">front</span>());<br>        m_queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T&amp; value)</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        m_cv.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>] &#123; <span class="hljs-keyword">return</span> !m_queue.<span class="hljs-built_in">empty</span>(); &#125;);<br><br>        value = std::<span class="hljs-built_in">move</span>(m_queue.<span class="hljs-built_in">front</span>());<br>        m_queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mutex)</span></span>;<br>        <span class="hljs-keyword">return</span> m_queue.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::queue&lt;T&gt; m_queue;<br>    <span class="hljs-keyword">mutable</span> std::mutex m_mutex;<br>    std::condition_variable m_cv;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="工作线程实现"><a href="#工作线程实现" class="headerlink" title="工作线程实现"></a>工作线程实现</h2><p>工作线程用于从不停任务队列中取任务并执行。这里定义了一个 WorkerThread 类，它的 operator() 函数不断地从任务队列中取出任务并执行，直到线程停止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerThread</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">WorkerThread</span>(ThreadSafeQueue&lt;std::function&lt;<span class="hljs-built_in">void</span>()&gt;&gt;&amp; taskQueue, std::atomic_bool&amp; running)<br>        : <span class="hljs-built_in">m_taskQueue</span>(taskQueue), <span class="hljs-built_in">m_running</span>(running) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (m_running) &#123;<br>            std::function&lt;<span class="hljs-type">void</span>()&gt; task;<br>            <span class="hljs-keyword">if</span> (m_taskQueue.<span class="hljs-built_in">try_pop</span>(task)) &#123;<br>                <span class="hljs-built_in">task</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                std::this_thread::<span class="hljs-built_in">yield</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    ThreadSafeQueue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt;&amp; m_taskQueue;<br>    std::atomic_bool&amp; m_running;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="线程池实现"><a href="#线程池实现" class="headerlink" title="线程池实现"></a>线程池实现</h2><p>这里定义了一个线程池类，为用户管理了任务队列和工作线程，线程线程池。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">size_t</span> numThreads = std::thread::<span class="hljs-built_in">hardware_concurrency</span>())<br>        : <span class="hljs-built_in">m_running</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; ++i) &#123;<br>            m_threads.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">WorkerThread</span>(m_taskQueue, m_running));<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ThreadPool</span>() &#123;<br>        m_running = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; thread : m_threads) &#123;<br>            thread.<span class="hljs-built_in">join</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">submit</span><span class="hljs-params">(Func&amp;&amp; func, Args&amp;&amp;... args)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> task = std::<span class="hljs-built_in">bind</span>(std::forward&lt;Func&gt;(func), std::forward&lt;Args&gt;(args)...);<br>        m_taskQueue.<span class="hljs-built_in">push</span>(task);<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadWorker</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (m_running) &#123;<br>            std::function&lt;<span class="hljs-type">void</span>()&gt; task;<br>            <span class="hljs-keyword">if</span> (m_taskQueue.<span class="hljs-built_in">try_pop</span>(task)) &#123;<br>                <span class="hljs-built_in">task</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                std::this_thread::<span class="hljs-built_in">yield</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ThreadSafeQueue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; m_taskQueue;<br>    std::vector&lt;std::thread&gt; m_threads;<br>    std::atomic&lt;<span class="hljs-type">bool</span>&gt; m_running;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Task &quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; started&quot;</span> &lt;&lt; std::endl;<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Task &quot;</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; finished&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ThreadPool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;  <span class="hljs-comment">// 创建一个包含 4 个工作线程的线程池</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>        pool.<span class="hljs-built_in">submit</span>(task, i);  <span class="hljs-comment">// 向线程池中添加 8 个任务</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>⚠ <strong>Note</strong>: 转载请注明出处</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 多态特性及简单示例</title>
    <link href="/2022/08/09/C++%20%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7%E5%8F%8A%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/"/>
    <url>/2022/08/09/C++%20%E5%A4%9A%E6%80%81%E7%89%B9%E6%80%A7%E5%8F%8A%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="C-多态特性及简单示例"><a href="#C-多态特性及简单示例" class="headerlink" title="C++ 多态特性及简单示例"></a>C++ 多态特性及简单示例</h1><p>C++ 是一种面向对象的编程语言，其中的多态特性允许开发者在运行时根据对象的类型来调用相应的函数。这里我会介绍 C++ 多态的概念和几种不同的实现方式，并提供一些代码示例。</p><h2 id="多态-🔎"><a href="#多态-🔎" class="headerlink" title="多态 🔎"></a>多态 🔎</h2><p>多态（polymorphism）是一种基于继承的机制，它允许不同的对象对同一消息作出不同的响应。换句话说，同样的方法调用可以在不同的对象上产生不同的结果。</p><p><strong>静态多态</strong>：也称为编译时多态，主要通过函数重载和模板实现。在编译时期就能够确定函数的调用版本或者类的实例类型，因此也称为静态绑定。例如，通过重载函数名和参数列表，我们可以在编译时就确定具体调用哪个函数版本。</p><p><strong>动态多态</strong>：也称为运行时多态，主要通过虚函数实现。在编译时期无法确定函数调用的版本，而是在运行时期根据实际对象类型来确定调用哪个函数版本。因此也称为动态绑定。我们可以在基类中声明虚函数，然后在派生类中重写该函数，当使用基类指针或引用调用虚函数时，实际调用的是该指针或引用所指向的对象类型的虚函数版本。</p><p>静态多态在编译时期就能够确定函数调用的版本，而动态多态需要在运行时期根据实际对象类型来确定函数调用的版本。多态机制使得我们能够编写通用的代码，更加灵活和可扩展。</p><h2 id="虚函数实现多态"><a href="#虚函数实现多态" class="headerlink" title="虚函数实现多态"></a>虚函数实现多态</h2><p>虚函数是 C++ 中实现多态的一种常用方式。虚函数是在基类中声明的，用 virtual 关键字来修饰，它允许派生类重写该函数。当调用该函数时，编译器会根据实际对象的类型来调用对应的重写函数。下面是一个虚函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing a shape...&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing a circle...&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Drawing a square...&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Shape* shape1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>();<br>    Shape* shape2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Square</span>();<br>    shape1-&gt;<span class="hljs-built_in">draw</span>();<br>    shape2-&gt;<span class="hljs-built_in">draw</span>();<br>    <span class="hljs-keyword">delete</span> shape1;<br>    <span class="hljs-keyword">delete</span> shape2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个基类 Shape，它包含了一个虚函数 draw()。我们还定义了两个派生类 Circle 和 Square，它们都重写了 draw() 函数。在 main 函数中，我们创建了两个指向 Shape 类型的指针，分别指向 Circle 和 Square 对象。我们调用它们的 draw() 函数，这会根据实际对象的类型来调用对应的重写函数，输出不同的结果。</p><h2 id="模板实现多态"><a href="#模板实现多态" class="headerlink" title="模板实现多态"></a>模板实现多态</h2><p>模板是 C++ 中另一种实现多态的方式。模板允许我们编写一种通用的函数或类，它可以根据实际类型的参数来生成不同的代码。这种技术被称为泛型编程。下面是一个模板函数的示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    std::cout &lt;&lt; value &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">print</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">print</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">3.14</span>);<br>    <span class="hljs-built_in">print</span>&lt;std::string&gt;(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个模板函数 print()，它可以接受任意类型的参数，并将其打印到标准输出中。在 main 函数中，我们调用了 print() 函数三次，分别传入 int、double 和 std::string 类型的参数。由于模板的特性，编译器会根据实际类型的参数来生成不同的代码，这样我们就实现了多态。</p><p>#总结<br>本篇博客介绍了 C++ 中多态的概念和两种不同的实现方式：虚函数和模板。虚函数是一种基于继承的机制，它允许派生类重写基类的函数，从而实现多态。模板是一种通用的编程技术，它可以根据实际类型的参数来生成不同的代码，也可以实现多态。希望本篇博客能够帮助你更好地理解 C++ 中的多态特性。</p><p>⚠ <strong>Note</strong>: 转载请注明出处</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell语法总结（2）</title>
    <link href="/2022/07/11/shell%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/11/shell%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Shell语法"><a href="#Shell语法" class="headerlink" title="Shell语法"></a>Shell语法</h2><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><ul><li><code>./aa.sh</code><ul><li>打开一个<strong>subshell</strong>去读取、执行aa.sh，而aa.sh<strong>需要有执行权限</strong></li><li>依赖首行明确解释器类型，否则就不在subshell中执行</li><li>通知系统在当前目录找aa.sh,而直接执行aa.sh&#96;，linux 系统将在 PATH里的目录里找aa.sh</li></ul></li><li><code>sh/bash aa.sh</code>  <ul><li>打开一个<strong>subshell</strong>运行解释器去读取、执行aa.sh，文件名作为参数，<strong>无需执行权限</strong></li><li>无需在首行写类似<code>#!/bin/bash*</code>来明确解释器</li></ul></li><li><code>source aa.sh</code><ul><li><strong>当前shell内</strong>读取、执行aa.sh，会保留和改变当前shell中的变量，<strong>无需执行权限</strong></li><li>soure可以简化为点号”.”，推荐点号</li></ul></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><p>$aa与${aa}没有区别，但是{}可以用来明确变量边界，同时支持拼接</p></li><li><p><code>readonly aa</code> 设置变量aa为只读</p></li><li><p><code>unset aa</code> 删除变量aa, 不能删只读变量</p></li><li><p>shell变量</p><ul><li>&#96;&#96;&#96;<br>$$ &#x2F;&#x2F; shell本身PID<br>$* $@  参数列表（不包括脚本文件名）<br>$# 参数列表中参数个数<br>$0 脚本文件名<br>$n 第n个参数<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### 字符串<br><br>+ 单引号里的任何字符都会原样输出，因而变量是无效的<br>+ 字符串长度 `$&#123;#string&#125;`<br>+ 截取子串 `$&#123;string:<span class="hljs-number">1</span>:<span class="hljs-number">4</span>&#125;` 截取string位置<span class="hljs-number">1</span>开始的<span class="hljs-number">4</span>个字符<br><br>#### 数组<br><br>```shell<br>array_name=(value0 value1 value2 value3) #不限定长度，下标从<span class="hljs-number">0</span>开始，空格分割<br>array_name[n]=valuen <br>$&#123;array_name[@]&#125; # 使用 @ 符号可以获取数组中的所有元素<br>length=$&#123;#array_name[@]&#125; # 取得数组元素的个数<br>lengthn=$&#123;#array_name[n]&#125; # 取得数组单个元素的长度<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><ul><li>&#96;&#96;&#96;shell<br>: &lt;&lt;’COMMENT’<br>something<br>COMMENT<br>或者<br>: &lt;&lt;!<br>something<br>!<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment">#### Shell编码</span><br><br><span class="hljs-comment">#### cd安全</span><br><br>+ cd可能由于错误路径、无权限等问题而失败，一旦失败后续操作将在错误目录上继续执行，引发误操作。<br>+ 通过添加错误判断并<span class="hljs-keyword">exit</span>方式避免错误操作。<br><br>```shell<br>cd foo || <span class="hljs-keyword">exit</span> <span class="hljs-regexp">//</span> <span class="hljs-keyword">exit</span>返回cd错误码<br>cd foo || &#123; echo <span class="hljs-string">&quot;Failure&quot;</span>; <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>; &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>进入当前脚本路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">(<span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(dirname $0)</span>&quot;</span>;<span class="hljs-built_in">pwd</span>)</span><br></code></pre></td></tr></table></figure><p>进入当前函数执行路径，如脚本A调用脚本B，在B中执行则得到B的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">( <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$( dirname <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BASH_SOURCE[0]&#125;</span>&quot;</span> )</span>&quot;</span> &amp;&amp; <span class="hljs-built_in">pwd</span> )</span><br></code></pre></td></tr></table></figure><h2 id="静波代码检视"><a href="#静波代码检视" class="headerlink" title="静波代码检视"></a>静波代码检视</h2><h4 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a>离线检测</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get install shellcheck<br>shellcheck file.sh<br></code></pre></td></tr></table></figure><h4 id="在线检测"><a href="#在线检测" class="headerlink" title="在线检测"></a>在线检测</h4><ul><li><p>在线检测<a href="https://www.shellcheck.net/%EF%BC%8C%E8%B4%B4%E5%85%A5%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B">https://www.shellcheck.net/，贴入代码，自动检测</a></p></li><li><p>注意加上 <code>#!/bin/bash</code>，否则报错</p></li></ul><p><img src="/img/shell-check.png" alt="shellcheck示意"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell语法总结（1）</title>
    <link href="/2022/05/14/shell_note/"/>
    <url>/2022/05/14/shell_note/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<a href="https://www.cnblogs.com/jingmoxukong/p/7867397.html">https://www.cnblogs.com/jingmoxukong/p/7867397.html</a></p><h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><blockquote><ul><li>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问 Linux 内核的服务。  </li><li>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 .sh。</li></ul></blockquote><h1 id="二、shell语法"><a href="#二、shell语法" class="headerlink" title="二、shell语法"></a>二、shell语法</h1><h3 id="1-指定解释器"><a href="#1-指定解释器" class="headerlink" title="1. #!指定解释器"></a>1. #!指定解释器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指定bash解释器</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span>  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定sh解释器</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br></code></pre></td></tr></table></figure><p><strong>注</strong>：不指定，执行的时候会提示没有权限</p><blockquote><p>Shell 的解释器种类众多，常见的有：</p></blockquote><ul><li>sh - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。</li><li>bash - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。</li><li>fish - 智能和用户友好的命令行 shell。</li><li>xiki - 使 shell 控制台更友好，更强大。</li><li>zsh - 功能强大的 shell 与脚本语言。</li></ul><h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2. 注释"></a>2. 注释</h3><ul><li>单行注释：#开头</li><li>多行注释：“:&lt;&lt;EOF”开头，”EOF”结尾</li></ul><h3 id="3-echo：输出"><a href="#3-echo：输出" class="headerlink" title="3. echo：输出"></a>3. echo：输出</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">输出hello，world!</span><br>echo &quot;hello, world!&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">\转义字符，输出“hello”</span><br>echo &quot;\&quot;hello\&quot;&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出到文件test.txt,没有则新建</span><br>echo &quot;test&quot; &gt; test.txt<br></code></pre></td></tr></table></figure><p><strong>注</strong>：一个echo, 后面自动换行</p><h3 id="4-printf输出"><a href="#4-printf输出" class="headerlink" title="4. printf输出"></a>4. printf输出</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">格式只指定了一个参数，但多出的参数仍然会按照该格式输出</span><br>printf &quot;%s %s %s\n&quot; a b c d<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Output:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> a b c</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"> d</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替</span><br>printf &quot;%s and %d \n&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash"> Output:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">  and 0</span><br></code></pre></td></tr></table></figure><p><strong>注</strong>：需手动添加换行</p><h3 id="5-变量"><a href="#5-变量" class="headerlink" title="5. 变量"></a>5. 变量</h3><blockquote><p>变量无需声明，直接赋值就会创建<br>访问方式，${变量} 或 $变量</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">dword=&quot;hello&quot;  # 声明变量<br>echo $&#123;dword&#125;  # 输出变量值<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Output: hello</span><br><br>readonly dword # 定义为只读<br><span class="hljs-meta prompt_"># </span><span class="language-bash">dword=<span class="hljs-string">&quot;bye&quot;</span>  <span class="hljs-comment"># 如果放开注释，执行时会报错</span></span><br><br>unset dword    # 删除变量<br>echo $&#123;dword&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Output: （空）</span><br></code></pre></td></tr></table></figure><h3 id="6-条件语句写在-中"><a href="#6-条件语句写在-中" class="headerlink" title="6. 条件语句写在[[]]中"></a>6. 条件语句写在[[]]中</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">x=10<br>y=20<br>if [[ $&#123;x&#125; &gt; $&#123;y&#125; ]]; then<br>   echo &quot;$&#123;x&#125; &gt; $&#123;y&#125;&quot;<br>elif [[ $&#123;x&#125; &lt; $&#123;y&#125; ]]; then<br>   echo &quot;$&#123;x&#125; &lt; $&#123;y&#125;&quot;<br>else<br>   echo &quot;$&#123;x&#125; = $&#123;y&#125;&quot;<br>fi<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Output: 10 &lt; 20</span><br></code></pre></td></tr></table></figure><h3 id="7-Debug"><a href="#7-Debug" class="headerlink" title="7. Debug"></a>7. Debug</h3><ul><li>-f: 禁止文件名展开（globbing）</li><li>-i: 让脚本以 交互 模式运行</li><li>-n: 读取命令，但不执行（语法检查）</li><li>-t: 执行完第一条命令后退出</li><li>-v: 在执行每条命令前，向stderr输出该命令 </li><li>-x: 在执行每条命令前，向stderr输出该命令以及该命令的扩展参数<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">写法1</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash -x</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">写法2,使用-启用选项，+禁用选项</span><br>set -x<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake常用操作总结</title>
    <link href="/2022/03/08/cmake_note/"/>
    <url>/2022/03/08/cmake_note/</url>
    
    <content type="html"><![CDATA[<p>参考：<br><a href="https://blog.csdn.net/comedate/article/details/108544656">https://blog.csdn.net/comedate/article/details/108544656</a><br><a href="https://blog.csdn.net/qq_37431083/article/details/125885308">https://blog.csdn.net/qq_37431083&#x2F;article&#x2F;details&#x2F;125885308</a></p><h1 id="一、CMake介绍"><a href="#一、CMake介绍" class="headerlink" title="一、CMake介绍"></a>一、CMake介绍</h1><ul><li><p>makefile: 源文件一个一个编译太麻烦，Makefile通过编写规则文件指定工程中哪些文件需要先编译，哪些需要后编译进行批处理编译；可以指定只编译新写出的代码，而不用全部重新编译，提高了开发效率。 </p></li><li><p>CMake：是一个开源、跨平台的编译、测试和打包工具，它使用比较简单的语言描述编译、安装的过程，<strong>自动输出</strong>Makefile或者project文件。</p><p>为什么不自己写Makefile：对于大型工程，Makefile很复杂，cmake可自动生成Makefile。</p><p>跨平台编译，也叫交叉编译，可在win平台上开发，编译成linux平台可执行的文件。</p><p>Project文件（即Object文件）: 由源文件通过编译过程产生，是一种中间代码文件，其文件格式在Windows下为 .obj 文件，UNIX下是 .o 文件。大量的Object文件组合在一起（该过程称为”链接”）组成了可执行文件。</p></li></ul><h1 id="二、CMakeLists-txt语法"><a href="#二、CMakeLists-txt语法" class="headerlink" title="二、CMakeLists.txt语法"></a>二、CMakeLists.txt语法</h1><h3 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h3><table><thead><tr><th>变量名</th><th>意义</th></tr></thead><tbody><tr><td>PROJECT_NAME</td><td>project名称，即使用PROJECT命令设置的名称</td></tr><tr><td>CMAKE_CXX_COMPILER</td><td>指定C++编译器</td></tr><tr><td>CMAKE_CXX_FLAGS</td><td>编译C++文件时的选项</td></tr><tr><td>CMAKE_CXX_STANDARD</td><td>C++标准</td></tr><tr><td>add_definitions</td><td>添加编译选项</td></tr><tr><td>EXECUTABLE_OUTPUT_PATH</td><td>可执行文件的存放路径</td></tr><tr><td>LIBRARY_OUTPUT_PATH</td><td>库文件的存放路径</td></tr><tr><td>CMAKE_BUILD_TYPE</td><td>build 类型(Debug, Release, …)，CMAKE_BUILD_TYPE&#x3D;Debug</td></tr><tr><td>BUILD_SHARED_LIBS</td><td>指定编译成静态库还是动态库</td></tr></tbody></table><ol><li>设置最低Cmake版本要求<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)  <br></code></pre></td></tr></table></figure></li><li><strong>project()</strong></li></ol><ul><li>PROJECT_NAME: 必选——用来设置工程名，设置后，会把设置的值存储在CMAKE_PROJECT_NAME变量中</li><li>VERSION：可选，工程版本号，有主版本号、次版本号、补丁版本号</li><li>DESCRIPTION：工程简单的的描述</li><li>HOMEPAGE_URL：工程主页url</li><li>LANGUAGES：工程使用的语言</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 指定项目名和编程语言,默认为C和C++（cxx），LANGUAGE关键字可省略</span><br><span class="hljs-keyword">project</span>(cmaketest cxx)<br><span class="hljs-comment"># 跟在其他关键字后不可省略</span><br><span class="hljs-keyword">project</span> (camketest VERSION <span class="hljs-number">10.2</span>.<span class="hljs-number">1.3</span> LANGUAGES “CXX”)<br></code></pre></td></tr></table></figure><ol start="3"><li>message 打印消息<br><code>message([FATAL_ERROR] “message to display” …)</code></li><li>set 可设置普通变量、环境变量、缓存条目<br> <code>set (normal_var a) #普通变量</code></li><li>生成可执行程序<br>#同一个文件夹下多个源文件的编译<br><code>add_executable (helloDemo demo.cxx demo_b.cxx)</code>     </li><li>指定头文件搜索路径<br><code>include_directories ($&#123;HELLO_SOURCE_DIR&#125;/Hello)</code></li><li>查找当前目录下所有源文件名，并将其存储到DIR_CURR中<br> <code>aux_source_directory(. DIR_CURR)</code></li><li>添加链接库，指明可执行文件helloDemo需要连接一个名为 function 的链接库<br><code>target_link_libraries(helloDemo function)</code></li></ol><h1 id="三、cmake命令"><a href="#三、cmake命令" class="headerlink" title="三、cmake命令"></a>三、cmake命令</h1><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-S</td><td>指定源文件根目录，必须包含一个CMakeLists.txt文件</td></tr><tr><td>-B</td><td>指定构建目录，构建生成的中间文件和目标文件的生成路径</td></tr><tr><td>-D</td><td>使用变量，格式为-D &lt;var&gt;&#x3D;&lt;value&gt;，-D后面的空格<strong>可省略</strong>,变量在CMakeLists.txt中定义</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">指明使用当前目录作为源文件目录，其中包含CMakeLists.txt文件；</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用build目录作为构建目录；</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">设定变量CMAKE_BUILD_TYPE的值为Debug，变量AUTHOR的值为RealCoolEngineer</span><br>cmake -S . -B build -DCMAKE_BUILD_TYPE=Debug -DAUTHOR=RealCoolEngineer<br></code></pre></td></tr></table></figure><h1 id="四、CMake使用"><a href="#四、CMake使用" class="headerlink" title="四、CMake使用"></a>四、CMake使用</h1><ol><li>生成Makefile文件<blockquote><p>cmake `CMakeLists.txt所在路径&#96;  &#x2F;&#x2F;会在当前文件夹生成build文件    </p></blockquote></li><li>编译:进入build文件，里面会有Makefile文件，执行make，即会生成可执行文件<blockquote><p>make</p></blockquote></li><li>直接输入可执行文件文件名，执行。</li></ol><h1 id="五、项目CMakeList-txt实例"><a href="#五、项目CMakeList-txt实例" class="headerlink" title="五、项目CMakeList.txt实例"></a>五、项目CMakeList.txt实例</h1><p>项目来源：<a href="https://github.com/CandyConfident/HighPerformanceConcurrentServer">https://github.com/CandyConfident/HighPerformanceConcurrentServer</a>  </p><p>out-of-source build，与in-source build相对，即将编译输出文件与源文件放到不同目录中。此项目为out-of-source build。</p><h3 id="build-sh"><a href="#build-sh" class="headerlink" title="build.sh"></a>build.sh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br><br>set -x<br><br>SOURCE_DIR=`pwd`<br>BUILD_DIR=$&#123;BUILD_DIR:-../build&#125;<br>BUILD_TYPE=$&#123;BUILD_TYPE:-Debug&#125; #表示是debug版本，不是release版本<br>DEBUG_FLAG=$&#123;DEBUG_FLAG:-1&#125;<br><br>mkdir -p $BUILD_DIR/$BUILD_TYPE \<br>    &amp;&amp; cd $BUILD_DIR/$BUILD_TYPE \<br>    &amp;&amp; cmake \<br>            -DCMAKE_BUILD_TYPE=$BUILD_TYPE \<br>            -DCMAKE_DEBUG_FLAG=$DEBUG_FLAG \<br>            $SOURCE_DIR \<br>    &amp;&amp; make $*<br></code></pre></td></tr></table></figure><h3 id="总CMakeLists-txt"><a href="#总CMakeLists-txt" class="headerlink" title="总CMakeLists.txt"></a>总CMakeLists.txt</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.16</span>) <span class="hljs-comment">#指定cmake最小版本</span><br><span class="hljs-keyword">project</span>(MyServer CXX) <span class="hljs-comment">#指定项目名和程序语言,cxx=c++</span><br><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">20</span>) <span class="hljs-comment">#指定C++标准</span><br><br><span class="hljs-keyword">if</span>(CMAKE_DEBUG_FLAG) <br>    <span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot; $&#123;CMAKE_CXX_FLAGS&#125; -g&quot;</span>)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">message</span>(STATUS <span class="hljs-string">&quot;CMAKE_CXX_FLAGS = &quot;</span> <span class="hljs-variable">$&#123;CMAKE_CXX_FLAGS&#125;</span>) <span class="hljs-comment">#打印消息</span><br><br><span class="hljs-comment"># 添加子目录,同时将子目录下的CMakeLists.txt文件执行</span><br><span class="hljs-keyword">add_subdirectory</span>(log/tests)<br><span class="hljs-keyword">add_subdirectory</span>(threadpool/tests)<br><span class="hljs-keyword">add_subdirectory</span>(timer/tests)<br><span class="hljs-keyword">add_subdirectory</span>(memory/tests)<br><span class="hljs-keyword">add_subdirectory</span>(net/tests)<br></code></pre></td></tr></table></figure><h3 id="子CMakeLists-txt"><a href="#子CMakeLists-txt" class="headerlink" title="子CMakeLists.txt"></a>子CMakeLists.txt</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">aux_source_directory</span>(.. native_source) <span class="hljs-comment">#将当前文件夹所有源文件名添加到上一级目录中native_source中</span><br><span class="hljs-keyword">set</span>(SRCS  <span class="hljs-comment">#设置SRCS变量为多个值</span><br>    test_mem.cpp<br>    ../../log/pr.cpp<br>    ../../log/log.cpp<br>)<br><span class="hljs-keyword">list</span>(APPEND SRCS <span class="hljs-variable">$&#123;native_source&#125;</span>)<br><br><span class="hljs-keyword">set</span>(INCS<br>    ../<br>    ../../log<br>)<br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;INCS&#125;</span>) <span class="hljs-comment">#指定头文件路径</span><br><br><span class="hljs-keyword">add_executable</span>(mem_test <span class="hljs-variable">$&#123;SRCS&#125;</span>) <span class="hljs-comment">#将SRCS中源文件生成可执行文件mem_test</span><br><span class="hljs-keyword">target_link_libraries</span>(mem_test pthread) <span class="hljs-comment">#添加链接库</span><br><br><span class="hljs-keyword">list</span>(REMOVE_ITEM SRCS test_mem.cpp)<br><span class="hljs-keyword">list</span>(APPEND SRCS test_buf.cpp)<br><span class="hljs-keyword">add_executable</span>(buf_test <span class="hljs-variable">$&#123;SRCS&#125;</span>)<br><span class="hljs-keyword">target_link_libraries</span>(buf_test pthread)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用操作总结</title>
    <link href="/2022/02/28/Git%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/02/28/Git%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="批量删除Git分支"><a href="#批量删除Git分支" class="headerlink" title="批量删除Git分支"></a>批量删除Git分支</h2><h3 id="删本地分支"><a href="#删本地分支" class="headerlink" title="删本地分支"></a>删本地分支</h3><p>git branch 输出分支列表， 通过管道过滤出包含关键词 keyname分支名的分支，传递给git branch -D 本地分支强制删除命令中，实现<strong>批量删除包含keyname字符串的本地分支</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">git branch |<span class="hljs-type">grep</span> &#x27;keyname&#x27; | <span class="hljs-type">xargs</span> git branch -D<br></code></pre></td></tr></table></figure><h4 id="删远程分支"><a href="#删远程分支" class="headerlink" title="删远程分支"></a>删远程分支</h4><p>git branch 输出分支列表， 通过管道过滤出包含关键词 keyname分支名的分支，传递给git push origin –delete 远端分支强制删除命令中，实现<strong>批量删除包含keyname字符串的远端分支</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">git branch |<span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;keyname&#x27;</span> | xargs git <span class="hljs-keyword">push</span> origin --<span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><h2 id="误删分支找回"><a href="#误删分支找回" class="headerlink" title="误删分支找回"></a>误删分支找回</h2><p>git reflog查看所有分支的commit记录,根据commit记录创建分支</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">git branch <span class="hljs-keyword">new</span><span class="hljs-type">BranchName</span> HEAD@&#123;**&#125;<br></code></pre></td></tr></table></figure><p>切换到新分支后，push到远端即可恢复远端分支</p><p><img src="/img/findback-branch.png" alt="找回分支"></p><h2 id="Git快捷命令配置（别名）"><a href="#Git快捷命令配置（别名）" class="headerlink" title="Git快捷命令配置（别名）"></a>Git快捷命令配置（别名）</h2><p>git bash窗口中vi &#x2F;etc&#x2F;bash.bashrc，在尾部添加如下代码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">alias <span class="hljs-attribute">gst</span>=<span class="hljs-string">&#x27;git status&#x27;</span><br>alias <span class="hljs-attribute">gdiff</span>=<span class="hljs-string">&#x27;git diff&#x27;</span><br>alias <span class="hljs-attribute">gadd</span>=<span class="hljs-string">&#x27;git add&#x27;</span><br>alias <span class="hljs-attribute">gci</span>=<span class="hljs-string">&#x27;git commit -m &quot;hello world&quot;&#x27;</span><br>alias <span class="hljs-attribute">gthis</span>=<span class="hljs-string">&#x27;git rev-parse --abbrev-ref HEAD&#x27;</span><br>alias <span class="hljs-attribute">gpush</span>=<span class="hljs-string">&#x27;git push origin `gthis`&#x27;</span><br>alias <span class="hljs-attribute">gco</span>=<span class="hljs-string">&#x27;git checkout&#x27;</span><br>alias <span class="hljs-attribute">gbr</span>=<span class="hljs-string">&#x27;git branch&#x27;</span><br>alias <span class="hljs-attribute">gname</span>=<span class="hljs-string">&#x27;vi /etc/bash.bashrc&#x27;</span><br></code></pre></td></tr></table></figure><p>保存后重启bash窗口，生效快捷命令映射</p><p>若保存时，遇到[&#x2F;etc&#x2F;bashrc Permission denied，则用管理员权限打开git bash重试即可</p><p><img src="/img/bash-run.png" alt="管理员权限运行bash"></p><h2 id="记录Git用户名密码"><a href="#记录Git用户名密码" class="headerlink" title="记录Git用户名密码"></a>记录Git用户名密码</h2><p>git 默认每次pull等操作时要求输入密码，比较麻烦，可通过如下命令永久保存密码，再输入一次后就无需输入了。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config credential.helper store<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高频VIM命令</title>
    <link href="/2021/11/15/%E9%AB%98%E9%A2%91VIM%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/11/15/%E9%AB%98%E9%A2%91VIM%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="VIM命令"><a href="#VIM命令" class="headerlink" title="VIM命令"></a>VIM命令</h2><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul><li>normal模式下用&#x2F;</li><li>用n查找下一个，N查找上一个</li><li>尾部加\c表示大小写不敏感，\C敏感，如&#x2F;foll\C</li><li>按下*，可查找光标所在单词（前后有空白），g*则可查光标所在字符序列</li></ul><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><ul><li>&#96;&#96;&#96;<br>:{作用范围}s&#x2F;{目标}&#x2F;{替换}&#x2F;{替换标志}<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><br>+ ```<br>  <span class="hljs-symbol">:%s/foo/bar/gc</span> <br>  <span class="hljs-comment"># %表示作用全文</span><br>  替换标志中g表示替换所有，没有表示只替换第一个<br>  替换标志中c表示需确认<br></code></pre></td></tr></table></figure></li></ul><h4 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h4><ul><li><p><strong>从windows复制到vim</strong>，需先按a&#x2F;i&#x2F;insert键进入插入模式，再右键粘贴，否则在命令模式下将识别为vim命令直至遇到i&#x2F;a</p></li><li><p><strong>复制选中区</strong>，光标在复制开始地方按v进入可视模式，结束地方按y复制，直待粘贴处按p粘贴</p></li><li><p>复制整行，yy</p></li><li><p>剪切整行，dd</p></li><li><p>粘贴,p， 粘贴在光标前为P</p></li></ul><h4 id="光标跳转"><a href="#光标跳转" class="headerlink" title="光标跳转"></a>光标跳转</h4><ul><li>文件首： gg</li><li>文件尾： shift + g</li><li>文件指定行： 行号（命令行模式）</li><li>行首： home键</li><li>行尾： end键</li></ul><h4 id="查历史命令"><a href="#查历史命令" class="headerlink" title="查历史命令"></a>查历史命令</h4><p>窗口中ctrl + R，输入关键词如<code>git commit</code>，将出现以该关键词为首的历史命令，通过多次ctrl + R来选择切换历史命令，然后通过右箭头选中命令</p><p><img src="/img/linux-cmd.png" alt="历史命令"></p><h4 id="tab设置"><a href="#tab设置" class="headerlink" title="tab设置"></a>tab设置</h4><ul><li><p>显示tab  命令模式下<code>set list</code></p></li><li><p>设置tab为4空格，且自动缩进， &#x2F;etc&#x2F;vimrc中添加</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">ts</span>=4<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">softtabstop</span>=4<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">shiftwidth</span>=4<br><span class="hljs-built_in">set</span> expandtab<br><span class="hljs-built_in">set</span> autoindent<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL语法总结</title>
    <link href="/2021/09/14/sql%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/09/14/sql%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一-打开"><a href="#一-打开" class="headerlink" title="一. 打开"></a>一. 打开</h1><p>打开SQL sever management studio -&gt; connect -&gt; 新建一个query</p><h1 id="二-SQL语句"><a href="#二-SQL语句" class="headerlink" title="二. SQL语句"></a>二. SQL语句</h1><blockquote><p>SQL语句对大小写不敏感，分为DDL（数据定义）语句，DML（数据操作）语句。</p><h4 id="DDL语句-创建、删除、增加索引、键、约束"><a href="#DDL语句-创建、删除、增加索引、键、约束" class="headerlink" title="DDL语句: 创建、删除、增加索引、键、约束"></a>DDL语句: 创建、删除、增加索引、键、约束</h4><ul><li>CREATE DATABASE - 创建新数据库</li><li>ALTER DATABASE - 修改数据库</li><li>CREATE TABLE - 创建新表</li><li>ALTER TABLE - 变更（改变）数据库表</li><li>DROP TABLE - 删除表</li><li>CREATE INDEX - 创建索引（搜索键）</li><li>DROP INDEX - 删除索引</li></ul><h4 id="DML语句：查询和更新"><a href="#DML语句：查询和更新" class="headerlink" title="DML语句：查询和更新"></a>DML语句：查询和更新</h4><ul><li>SELECT - 从数据库表中获取数据</li><li>UPDATE - 更新数据库表中的数据</li><li>DELETE - 从数据库表中删除数据</li><li>INSERT INTO - 向数据库表中插入数据</li></ul></blockquote><h3 id="1-切换数据库"><a href="#1-切换数据库" class="headerlink" title="1. 切换数据库"></a>1. 切换数据库</h3><p> <code>use database_name</code></p><h3 id="2-创建数据库"><a href="#2-创建数据库" class="headerlink" title="2. 创建数据库"></a>2. 创建数据库</h3><p> <code>create database database_name</code></p><h3 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h3><blockquote><p>create table 表名(<br> 列名1 数据类型 是否为空（可省略）,<br> 列名2 数据类型 是否为空（可省略）,<br> …<br> )<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>建表students, 主键为student__ID<br> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> students(<br> s_ID <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> key,<br> s_name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br> s_sex <span class="hljs-type">char</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br> s_phoneNumber <span class="hljs-type">varchar</span>(<span class="hljs-number">11</span>)<br>)<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="4-删除表"><a href="#4-删除表" class="headerlink" title="4. 删除表"></a>4. 删除表</h3><p> <code>drop table table_name</code></p><h3 id="5-插入数据"><a href="#5-插入数据" class="headerlink" title="5. 插入数据"></a>5. 插入数据</h3><blockquote><ul><li>可不写全所有列<br> insert into table_name(列名1，列名2，..)values(值1，值2，..)  </li><li>省略列名，必须写全所有列<br>insert into table_name values(值1，值2，..)</li><li>一次性插入多组值<br> insert into table_name values<br> (值1，值2，..)，<br> (值1，值2，..)，<br> (值1，值2，..)<br> <strong>注</strong>：字符串用单引号括起来 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>方法<span class="hljs-number">1</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> students(s_ID, s_name, s_sex, s_phoneNumber)<span class="hljs-keyword">values</span>(<span class="hljs-number">01</span>, <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;121212121&#x27;</span>)<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> students(s_ID, s_name, s_sex)<span class="hljs-keyword">values</span>(<span class="hljs-number">06</span>, <span class="hljs-string">&#x27;luna&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>方法<span class="hljs-number">2</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> students <span class="hljs-keyword">values</span>(<span class="hljs-number">02</span>, <span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;221212121&#x27;</span>)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>方法<span class="hljs-number">3</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> students <span class="hljs-keyword">values</span><br>(<span class="hljs-number">03</span>, <span class="hljs-string">&#x27;Amy&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;201212121&#x27;</span>),<br>(<span class="hljs-number">04</span>, <span class="hljs-string">&#x27;bree&#x27;</span>, <span class="hljs-string">&#x27;女&#x27;</span>,<span class="hljs-string">&#x27;921212121&#x27;</span>),<br>(<span class="hljs-number">05</span>, <span class="hljs-string">&#x27;mike&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;821212121&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul></blockquote><h3 id="6-删除数据"><a href="#6-删除数据" class="headerlink" title="6. 删除数据"></a>6. 删除数据</h3><blockquote><p>delete from 表名 where 条件，&#x3D;&#x3D;没有条件的话，整张表都会被删除&#x3D;&#x3D;<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> s_ID <span class="hljs-operator">=</span> <span class="hljs-number">01</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> students<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="7-修改表结构"><a href="#7-修改表结构" class="headerlink" title="7. 修改表结构"></a>7. 修改表结构</h3><blockquote><p><strong>增加列：</strong> alter table 表名 add  字段名 数据类型<br><strong>删除列：</strong> alter table 表名 drop column 字段名<br><strong>修改字段类型：</strong> alter table 表名 alter column 字段名 新类型</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>增加列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> students <span class="hljs-keyword">add</span> s_age <span class="hljs-type">int</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>删除列<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> students <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> s_age<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>修改字段类型<br><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> students <span class="hljs-keyword">alter</span> <span class="hljs-keyword">column</span> s_age <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><h3 id="8-更改数据"><a href="#8-更改数据" class="headerlink" title="8. 更改数据"></a>8. 更改数据</h3><blockquote><p>update 表名 set 列名 &#x3D; 列值, 列名 &#x3D; 列值,.. where 条件, &#x3D;&#x3D;不写条件则修改全表&#x3D;&#x3D;<br><code>update students set s_age = 20</code></p></blockquote><h3 id="9-查询"><a href="#9-查询" class="headerlink" title="9. 查询"></a>9. 查询</h3><ul><li><h4 id="查全表"><a href="#查全表" class="headerlink" title="查全表"></a>查全表</h4></li></ul><blockquote><p>select * from 表名</p></blockquote><ul><li><h4 id="查部分列"><a href="#查部分列" class="headerlink" title="查部分列"></a>查部分列</h4></li></ul><blockquote><p>select 列名1, 列名2 from 表名</p></blockquote><ul><li><h4 id="列取别名"><a href="#列取别名" class="headerlink" title="列取别名"></a>列取别名</h4></li></ul><blockquote><p>select 列名1 as 新列名1, 列名2 新列名2 from 表名<br><strong>注</strong>：as可以省略</p></blockquote><ul><li><h4 id="列名加运算符"><a href="#列名加运算符" class="headerlink" title="列名加运算符"></a>列名加运算符</h4></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询学生姓名以及学生两年前的年龄<br><span class="hljs-keyword">select</span> s_name <span class="hljs-keyword">as</span> 姓名, s_age<span class="hljs-number">-2</span> 两年前的年龄 <span class="hljs-keyword">from</span> students<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询学生姓名、两年前的年龄<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>isnull(expr1,expr2)用于避免<span class="hljs-keyword">null</span>值参与计算  MySQL用ifnull()<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>如果expr1是<span class="hljs-keyword">null</span>,函数的结果就是expr2;否则就是expr1<br><span class="hljs-keyword">select</span> s_name, isnull(s_age, <span class="hljs-number">20</span>)<span class="hljs-number">-2</span> <span class="hljs-keyword">from</span> students<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>可用<span class="hljs-operator">+</span>做字符串或列与列的拼接,列得是字符串型 <br><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;姓名:&#x27;</span><span class="hljs-operator">+</span>s_name<span class="hljs-operator">+</span>s_sex <span class="hljs-keyword">from</span> students<br></code></pre></td></tr></table></figure><ul><li><h4 id="distinct关键字"><a href="#distinct关键字" class="headerlink" title="distinct关键字"></a>distinct关键字</h4></li></ul><blockquote><p>去掉重复的行，所查字段都一样才会被去掉<br><code>select distinct class_ID, s_name from students</code></p></blockquote><ul><li><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4></li></ul><blockquote><ol><li>比较运算：&gt;、&lt; 、&gt;&#x3D;、&lt;&#x3D;、&#x3D;、&#x3D; 、!&#x3D;或&lt;&gt;<br><strong>注</strong>： null值不能作比较<br>NULL值与任何其它值的比较（即使是NULL）永远不会为“真”</li><li>between … and … 数值范围条件<br><strong>注</strong>：包括边界</li><li>in关键字，集合列表范围查询<br><strong>注</strong>：not in集合里不能包含null值，因为要判断和集合里的所有元素都不等才会返回true，包含null值无法比较，任何与之比较的元素都会返回false</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询tom的全部信息<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> s_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;tom&#x27;</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询不属于<span class="hljs-number">1</span>班的学生<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> class_ID <span class="hljs-operator">!=</span> <span class="hljs-number">1</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询年龄在<span class="hljs-number">21</span><span class="hljs-number">-29</span>之间的学生<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> s_age <span class="hljs-keyword">between</span> <span class="hljs-number">21</span> <span class="hljs-keyword">and</span> <span class="hljs-number">29</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查Jack、linda、tom的信息<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> s_name <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;jack&#x27;</span>,<span class="hljs-string">&#x27;linda&#x27;</span>,<span class="hljs-string">&#x27;tom&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>逻辑运算：and、or、not<br><strong>注</strong>：and的优先级高于or，也可以使用小括号强制优先级</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询属于<span class="hljs-number">1</span>班且学号小于<span class="hljs-number">5</span>的学生<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> class_ID <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s_ID <span class="hljs-operator">&lt;</span> <span class="hljs-number">5</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询除tom之外的学生信息<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> s_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;tom&#x27;</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询姓名为tom，或学号为<span class="hljs-number">2</span>的学生<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> s_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;tom&#x27;</span> <span class="hljs-keyword">or</span> s_ID <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>判空： is null、is not null</li></ol></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询电话号码为空的学生<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> s_phoneNumber <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>模糊查询：like + %或_<br> %表示0个或多个字符，_表示一个字符 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询姓名以l开头的学生<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> s_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;l%&#x27;</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询名字里含m的学生<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> s_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%m%&#x27;</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询名字第二个字符为o的<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <span class="hljs-keyword">where</span> s_name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;_o%&#x27;</span><br></code></pre></td></tr></table></figure></li></ol></blockquote><ul><li><h4 id="order-by-对结果集排序"><a href="#order-by-对结果集排序" class="headerlink" title="order by 对结果集排序"></a>order by 对结果集排序</h4></li></ul><blockquote><p>默认升序asc,降序为desc<br> <strong>注</strong>：升序null值会排在最前面<br> select 列1， 列2 from 表名 order by 列名1<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>先按年龄升序，年龄一样则按学号升序<br><span class="hljs-keyword">select</span> s_name, s_age, s_ID <span class="hljs-keyword">from</span> students <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> s_age, s_ID <br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先按年龄降序，年龄一样按学号升序<br> <span class="hljs-keyword">select</span> s_name, s_age, s_ID <span class="hljs-keyword">from</span> students <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> s_age <span class="hljs-keyword">desc</span>, s_ID<br></code></pre></td></tr></table></figure></p></blockquote><ul><li><h4 id="top关键字：限定查询记录条数"><a href="#top关键字：限定查询记录条数" class="headerlink" title="top关键字：限定查询记录条数"></a>top关键字：限定查询记录条数</h4></li></ul><p>  <strong>注</strong>：mysql用limit(a, b),表示从a开始条记录，a从0开始计数。limit(n)表示返回前n条<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询前三名学生<br><span class="hljs-keyword">select</span> top <span class="hljs-number">3</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查第n<span class="hljs-operator">-</span>m条记录<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">select</span> top m<span class="hljs-operator">-</span>n<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 列名 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> top n<span class="hljs-number">-1</span> 列名 <span class="hljs-keyword">from</span> 表名)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询<span class="hljs-number">2</span><span class="hljs-number">-7</span>名学生<br><span class="hljs-keyword">select</span> top <span class="hljs-number">6</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> students <br><span class="hljs-keyword">where</span> s_ID <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> s_ID <span class="hljs-keyword">from</span> students)<br></code></pre></td></tr></table></figure></p><ul><li><h4 id="聚合函数：max、min、count、sum、avg"><a href="#聚合函数：max、min、count、sum、avg" class="headerlink" title="聚合函数：max、min、count、sum、avg"></a>聚合函数：max、min、count、sum、avg</h4></li></ul><blockquote><p><strong>注</strong>：count(),只要括号里的不为null，都加1<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>查年龄总值、最大值、电话不为空记录数<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(s_age) sum, <span class="hljs-built_in">max</span>(s_age) max, <span class="hljs-built_in">avg</span>(s_age) avg, <span class="hljs-built_in">count</span>(s_phoneNumber) count <span class="hljs-keyword">from</span> students<br></code></pre></td></tr></table></figure></p></blockquote><ul><li><h4 id="分组查询：group-by"><a href="#分组查询：group-by" class="headerlink" title="分组查询：group by"></a>分组查询：group by</h4></li></ul><blockquote><p><strong>注</strong>：查询的列要在group by子句中；sql sever 不能取别名， MySQL可以<br>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>按年龄分组<br><span class="hljs-keyword">select</span> s_age <span class="hljs-keyword">from</span> students <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s_age<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>计算每组记录数<br><span class="hljs-keyword">select</span> s_age, <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> students <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s_age<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>按年龄和性别分组<br><span class="hljs-keyword">select</span> s_age, s_sex <span class="hljs-keyword">from</span> students <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s_age, s_sex<br></code></pre></td></tr></table></figure><br>  <strong>注</strong>：在where语句中不能使用聚合函数，可以在having语句中使用聚合函数</p></blockquote><p> where是对每条表记录的条件限定，having是对结果集记录的条件限定<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s_sex, <span class="hljs-built_in">avg</span>(s_age) <span class="hljs-keyword">from</span> students <br><span class="hljs-keyword">group</span> bys_sex <br><span class="hljs-keyword">having</span> <span class="hljs-built_in">avg</span>(s_age) <span class="hljs-operator">&gt;</span> <span class="hljs-number">25</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先筛出年龄<span class="hljs-operator">&gt;</span><span class="hljs-number">25</span>的，再按年龄分组，在筛出分组后年龄大于<span class="hljs-number">29</span>的<br> <span class="hljs-keyword">select</span> s_age <span class="hljs-keyword">from</span> students <br> <span class="hljs-keyword">where</span> s_age <span class="hljs-operator">&gt;</span> <span class="hljs-number">25</span> <br> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> s_age <br> <span class="hljs-keyword">having</span> s_age <span class="hljs-operator">&gt;</span> <span class="hljs-number">29</span><br></code></pre></td></tr></table></figure></p><ul><li><h4 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h4></li></ul><blockquote><ol><li>等值连接 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查学生信息和专业<br><span class="hljs-keyword">select</span> student.<span class="hljs-operator">*</span>, class.Speciality <br><span class="hljs-keyword">from</span> student, class <br><span class="hljs-keyword">where</span> student.clno <span class="hljs-operator">=</span> class.clno<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>取别名<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student s, class c <span class="hljs-keyword">where</span> s.clno <span class="hljs-operator">=</span> c.clno<br></code></pre></td></tr></table></figure></li><li>内连接<br>  select 列1，列2 from 表1<br>inner join 表2<br>on 等值条件  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> s.<span class="hljs-operator">*</span>, c.Speciality <span class="hljs-keyword">from</span> student s <br><span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> class c <span class="hljs-keyword">on</span> s.clno <span class="hljs-operator">=</span> c.clno <br><span class="hljs-keyword">where</span> sage <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>  <strong>注</strong>：内连接的结果和等值连接的结果是相同的，只是写法不同<br>  只会显示符合连接条件的数据，不会显示所有的数据</li><li>外连接：<br>分为左外连接、右外连接，左外连接会列出左表全部记录，右表没有符合的记录则用null值填充；右外连接会列出右表全部记录，左表没有符合的记录则用null值填充  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student s <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> class c <span class="hljs-keyword">on</span> c.clno <span class="hljs-operator">=</span> s.clno<br></code></pre></td></tr></table></figure></li><li>全连接：表1 full join 表2 on 连接条件<br>   <strong>注</strong>：mysql没有full join，可用左连接union右连接代替</li></ol></blockquote><ul><li><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4></li></ul><blockquote><ul><li>相关子查询：子查询中需要用到父查询中的值<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>查询某同学选修课程成绩高于他选修的所有课程平均成绩的课程号<br><span class="hljs-keyword">select</span> cno <span class="hljs-keyword">from</span> sc x <span class="hljs-keyword">where</span> grade <span class="hljs-operator">&gt;</span> <br>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(grad) <span class="hljs-keyword">from</span> sc y <span class="hljs-keyword">where</span> x.sno <span class="hljs-operator">=</span> y.sno)<br></code></pre></td></tr></table></figure>工作原理：扫描父查询表（如 SC 表）中的每一条记录，然后将当前这条记录中的，在子查询中会用到的值代入到子查询中去，然后执行子查询并得到结果（可以看成是返回值），然后再将这个结果代入到父查询的条件中，判断父查询的条件表达式的值是否为 True，若为 True，则将当前 SC 表中的这条记录放到结果集中去。若为 False 则不放。</li><li>非相关子查询：脱离父查询单独执行</li><li>子查询的结果只有一行就是<strong>单行子查询</strong>；反之就是<strong>多行子查询</strong>。单行子查询只能进行比较。多行子查询可用in、any、all、exists、not exists<br><strong>exist原理</strong>：<a href="https://zhuanlan.zhihu.com/p/20005249">https://zhuanlan.zhihu.com/p/20005249</a></li></ul></blockquote><ul><li><h4 id="取交集：union、union-all"><a href="#取交集：union、union-all" class="headerlink" title="取交集：union、union all"></a>取交集：union、union all</h4><blockquote><p>union会排除重复行，并排序，union all不会<br>union all执行效率更高</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">  <span class="hljs-operator">/</span><span class="hljs-operator">/</span>找出id为奇数且name不以m开头的员工bonus为salary，否则为<span class="hljs-number">0</span>，并排序<br>  <span class="hljs-keyword">select</span> employee_id, salary bonus <span class="hljs-keyword">from</span> Employees  <br>  <span class="hljs-keyword">where</span> employee_id <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;m%&#x27;</span>  <br>  <span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span>  <br>  <span class="hljs-keyword">select</span> employee_id, salary<span class="hljs-operator">*</span><span class="hljs-number">0</span> bonus <span class="hljs-keyword">from</span> Employees  <br>  <span class="hljs-keyword">where</span> employee_id <span class="hljs-operator">%</span> <span class="hljs-number">2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;m%&#x27;</span><br>  <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> employee_id<br>  ```  <br># 三、例句<br><span class="hljs-number">1.</span> <span class="hljs-keyword">case</span>用法<br>``` <span class="hljs-keyword">sql</span><br><span class="hljs-keyword">select</span> id,<br>    <span class="hljs-keyword">case</span> <span class="hljs-keyword">when</span> p_id <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;Root&#x27;</span><br>        <span class="hljs-keyword">when</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> p_id <span class="hljs-keyword">from</span> tree) <span class="hljs-keyword">then</span> <span class="hljs-string">&#x27;Inner&#x27;</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;Leaf&#x27;</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">as</span> Type<br><span class="hljs-keyword">from</span> tree<br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li><strong>mysql</strong> datadiff(date1, date2)函数<blockquote><p>函数返回date1 -date2的计算结果;如果参数传递的是日期时间值，DATEDIFF函数仅将日期部分用于计算，并&#x3D;&#x3D;忽略时间部分&#x3D;&#x3D;</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> activity_date <span class="hljs-keyword">day</span>, <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span>  user_id) active_users<br><span class="hljs-keyword">FROM</span> Activity<br><span class="hljs-keyword">WHERE</span> DATEDIFF(&quot;2019-07-27&quot;, activity_date) <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span> <span class="hljs-keyword">AND</span> DATEDIFF(&quot;2019-07-27&quot;, activity_date) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> activity_date;<br></code></pre></td></tr></table></figure><blockquote><p>TIMESTAMPDIFF(DAY,start,end):返回两个日期指定单位的时间差(指定单位可以是年，季度，月，星期，天数，小时，分钟，秒等等)</p></blockquote></li><li>if(条件, 为true时&#x3D;, 为false时&#x3D;)<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>性别转换<br><span class="hljs-keyword">update</span> Salary <span class="hljs-keyword">set</span> sex <span class="hljs-operator">=</span> if(sex <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><strong>注</strong>：子查询要命名，不然会报错。<br>  <strong>注</strong>：不能在同一个 sql 语句中，先 select 同一个表的某些值，然后再 update 这个表。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">from</span> Person <span class="hljs-keyword">Where</span> Id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <br>(<span class="hljs-keyword">select</span> Id <span class="hljs-keyword">from</span> <br>( <span class="hljs-keyword">Select</span> <span class="hljs-built_in">MIN</span>(Id) <span class="hljs-keyword">as</span> Id <span class="hljs-keyword">From</span> Person <span class="hljs-keyword">Group</span> <span class="hljs-keyword">by</span> Email ) t)<br></code></pre></td></tr></table></figure></li><li>concat(a, b)拼接a,b ;left(name,count)返回name前count字符。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> user_id, <br>concat(<span class="hljs-built_in">upper</span>(<span class="hljs-keyword">left</span>(name, <span class="hljs-number">1</span>)), <span class="hljs-built_in">lower</span>(substr(name, <span class="hljs-number">2</span>))) name<br><span class="hljs-keyword">from</span> Users <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> user_id<br></code></pre></td></tr></table></figure></li><li>groupconcat()：将分组后每组的某一字段拼接起来。默认用,分割<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> sell_date,<span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> product) num_sold,<br>group_concat(<span class="hljs-keyword">distinct</span> product separator <span class="hljs-string">&#x27;,&#x27;</span>) products<br><span class="hljs-keyword">from</span> activities<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> sell_date<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> sell_date<br></code></pre></td></tr></table></figure></li><li>with tableA as（select语句）：相当于建立了一个临时表tableA<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">with</span> tmp <span class="hljs-keyword">as</span><br>(<span class="hljs-keyword">select</span> employee_id <span class="hljs-keyword">from</span> Employees<br><span class="hljs-keyword">union</span> <span class="hljs-keyword">all</span><br><span class="hljs-keyword">select</span> employee_id <span class="hljs-keyword">from</span> Salaries)<br><span class="hljs-keyword">select</span> employee_id <span class="hljs-keyword">from</span> tmp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure></li><li><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>加引号表示将固定值store1放到列store<br><span class="hljs-keyword">select</span> product_id,&quot;store1&quot; store, store1 price <span class="hljs-keyword">from</span> Products <span class="hljs-keyword">where</span> store1 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="四、"><a href="#四、" class="headerlink" title="四、"></a>四、</h1><ol><li>e-r图与关系模式转换<ul><li>1对1关系：任一方的主键加入到另一方中。</li><li>1对n关系：1方的主键加入到n方，并把联系上的属性也加入到n方。</li><li>m对n关系：联系自成一张表，并把双方的主键加进来当联合主键。</li></ul></li><li>数据库设计规范——三大范式</li></ol><ul><li>第一范式：保持每列的原子性，即每个字段都是不可拆分的原子值。</li><li>第二范式：确保每列都和主键相关，而不能和主键的某一部分相关（针对联合主键）。为避免数据冗余。<br>  可能存在的问题：数据冗余、删除异常、插入异常、更新异常<br>  例如：订单信息表中主键为订单编号和商品编号，属性包括，商品订购数量，商品价格，商品型号等。因为存在不同订单订购同一商品，因此同一个商品的信息可能被记录多次（数据冗余）；删除一条记录可能会删除一类商品的信息（删除异常）；插入一个商品信息必须要有订单号（插入异常）；更新一类商品信息要操作好几行（更新异常）。<br>  它不满足第二范式，商品价格、商品型号只与商品有关，应该建一张商品表，订单信息表只保留商品编号、订购数量等。</li><li>第三范式：必须满足第二范式。非主属性必须直接依赖于主键，不能传递依赖于非主属性。</li></ul><ol start="3"><li>函数依赖<ul><li>部分函数依赖：（A,B）决定C,A也能决定C或B也能决定C，则C部分依赖于（A,B）</li><li>完全函数依赖：（A,B）决定C,A不能决定C,B不能决定C，则C完全函数依赖于（A,B）</li><li>传递依赖：A-&gt;B(B!-&gt;A),B-&gt;C，则C传递依赖于x<br>例：学号，宿舍，住宿费</li></ul></li><li><ul><li>mysql的执行过程<br><a href="https://www.jianshu.com/p/338092a0a8c6">https://www.jianshu.com/p/338092a0a8c6</a></li><li>索引<a href="https://bbs.huaweicloud.com/blogs/333163">https://bbs.huaweicloud.com/blogs/333163</a></li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown学习笔记</title>
    <link href="/2021/08/10/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/10/markdown%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>#<del>######：一级标题</del>六级标题（一级最大）</p><p>列表：<br>在首部添加 -、+、* 可形成无序列表<br>数字加. 可形成有序列表</p><p>文字样式：<br>加粗：<strong>文字</strong><br>标记：&#x3D;&#x3D;文字&#x3D;&#x3D; （文字会变黄）<br>删除文本：<del>文字</del> （文字会画上一条线）</p><p>图片：<br><img src="/%E9%93%BE%E6%8E%A5" alt="文字，可省略"></p><p>链接:<br><a href="%E9%93%BE%E6%8E%A5">文字</a><br>或者直接用&lt;&gt;括起来</p><p>引用</p><blockquote><p>、&gt;&gt;、&gt;&gt;&gt;分别表示一级、二级、三级引用（引用就是用灰框框起来,里面可以放文字、代码、分割线、标题、列表等）</p></blockquote><p>代码：<br>行内代码，用&#96;&#96;包起来<br>代码块，用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">代码块<br></code></pre></td></tr></table></figure><p>(代码高亮显示在&#96;&#96;&#96;后面加空格和语言种类)</p><p>表格：</p><table><thead><tr><th align="left">标题</th><th>标题</th><th align="right">标题</th></tr></thead><tbody><tr><td align="left">居左</td><td>居中</td><td align="right">居右</td></tr><tr><td align="left">冒号在左边</td><td>没有冒号</td><td align="right">冒号在右边</td></tr></tbody></table><p>分割线<br>用三个以上*或-或_</p><p>脚注<br>文字后面加<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="xxxx (写在文章末尾)">[1]</span></a></sup><br>并注明 </p><p>换行<br>两个空格+换行</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>xxxx (写在文章末尾)<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ std::priority_queue优先队列详解</title>
    <link href="/2021/03/14/C-std-priority-queue%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/03/14/C-std-priority-queue%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="STL-priority-queue优先队列"><a href="#STL-priority-queue优先队列" class="headerlink" title="STL priority_queue优先队列"></a>STL priority_queue优先队列</h2><p>优先队列是一种容器适配器，队列元素要求实现了严格弱排序（Strict Weak Ordering），保证队列顶点（top）元素始终为最大值（最小值）。</p><p>优先队列本质上是一种堆，默认最大堆，即每一个父节点的值都比其子节点要大，因此根节点中的元素总是树中的最大值，因此常用于最值的读取。在时间复杂度上，优先队列实现单个元素的增删都是O(log n)，而读取队列顶点则为O(1)</p><h2 id="接口原型-🔎"><a href="#接口原型-🔎" class="headerlink" title="接口原型 🔎"></a>接口原型 🔎</h2><p>如下接口定义可以看出，优先队列的定义包含三个元素：</p><ul><li>元素类型T；</li><li>存储元素的基础容器类型，要求为拥有连续内存分布的<a href="https://en.cppreference.com/w/cpp/named_req/SequenceContainer">SequenceContainer</a>， STL中满足的就是std::vector and std::deque两种了；</li><li>元素比较函数Compare， Compare函数主要用于元素比较，实现严格的弱排序，由于排序，优先队列已经不满足“先进先出”的特性了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = vector&lt;T&gt;,<br>  <span class="hljs-keyword">class</span> Compare = less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt; &gt; <span class="hljs-keyword">class</span> priority_queue;<br></code></pre></td></tr></table></figure><h2 id="主要成员函数"><a href="#主要成员函数" class="headerlink" title="主要成员函数"></a>主要成员函数</h2><p>所有STL标准库实现的数据结构，都有对应的CRUD（增删改查）接口，形式也基本类似.</p><p><img src="/img/priority_queues_feat.png" alt="优先队列出入示意图"></p><p><img src="/img/priority_queue_member_function.png" alt="成员函数详解表"></p><h2 id="Comp函数"><a href="#Comp函数" class="headerlink" title="Comp函数"></a><strong>Comp函数</strong></h2><p>comp函数默认为使用仿函数<code>std::less&lt;int&gt;</code>,表示最大堆 ，这里less是降序，但由于优先队列将top指向了队列尾；同理，<code>std::greater&lt;T&gt;</code>,表示最小堆.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> = less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt; <br></code></pre></td></tr></table></figure><p>comp函数要求严格弱排序，那么什么是严格弱排序</p><p>维基百科给出了如下定义，简言之就是内置类型会通过<code>!(a &lt; b) &amp;&amp; !( b &lt; a ) </code>来判断ab是否相等，如果判断中携带了<code>=</code>如<code>&gt;=</code>、<code>&lt;=</code>，将导致相等判断逻辑出现错误。</p><blockquote><p>A Strict Weak Ordering is a Binary Predicate that compares two objects, returning true if the first precedes the second. This predicate must satisfy the standard mathematical definition of a strict weak ordering. The precise requirements are stated below, but what they roughly mean is that a Strict Weak Ordering has to behave the way that “less than” behaves: if a is less than b then b is not less than a, if a is less than b and b is less than c then a is less than c, and so on.</p></blockquote><p>另外当元素类型T为自定义类型时，那就需要自定义的comp函数，一般有实现后缀运算<code>()</code>函数 和 重载关系运算符 <code>&lt;</code>、 <code>&gt;</code> 两种方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span> <span class="hljs-comment">// priority_queue头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span> <span class="hljs-comment">// 仿函数头文件</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-type">int</span> x, y; <br><span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125; <br>&#125;;<br> <br><span class="hljs-comment">// &lt;操作符用于仿函数std::less</span><br><span class="hljs-comment">// node比较先按照x降序，x相等时，再按照y降序</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (Node a, Node b) <br>&#123; <br>      <span class="hljs-keyword">if</span> (a.x &gt; b.x) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.x == b.x) &#123;<br><span class="hljs-keyword">return</span> a.y &gt; b.y; <span class="hljs-comment">// 严格弱排序</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;      <br>&#125;<br><br>std::priority_queue&lt;Node, std::vector&lt;Node&gt;, std::less&lt;Node&gt;&gt; pq; <span class="hljs-comment">// 大顶堆</span><br><br><span class="hljs-comment">// &gt;操作符用于仿函数std::greater</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt; (Node a, Node b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a.x&gt; b.x;<br>&#125;<br><br>std::priority_queue&lt;Node, std::vector&lt;Node&gt;, std::greater&lt;Node&gt;&gt; pq; <span class="hljs-comment">// 小顶堆</span><br><br><span class="hljs-comment">// 自定义后缀操作符</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Node a,Node b)</span></span><br><span class="hljs-function">    </span>&#123;<br>  <span class="hljs-keyword">return</span> a.x &gt; b.x;<br>    &#125;<br>&#125;;<br><br>std::priority_queue&lt;Node, std::vector&lt;Node&gt;, cmp&gt; pq;<br><br></code></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>优先队列作为数据结构中堆的一种具体实现，在leetcode算法题中出现频率较高。比如这题<a href="https://leetcode.com/problems/maximum-average-pass-ratio/">leetcode 1792. Maximum Average Pass Ratio</a></p><p>在如下解答中，可以发现priority_queue的几个关键接口的使用。</p><p>另外算法层面可以看到，通过对优先队列进行增删读元素，使得每次都对最值进行操作，也就保证了每次操作都为最优解。实际上这就是<strong>贪心算法，通过求解每个子问题的最优解，来得到整个问题的最终最优解</strong>。也正因如此，优先队列就常在一些有约束条件下的分配问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// !!整数除法一定先转double, 注意检查括号</span><br>    <span class="hljs-comment">// !!乘法注意溢出，少量的除法误差可以容忍</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> cal(xy) ((double)(xy[0] +1) / (xy[1] + 1) - (double)(xy[0]) / (xy[1]))</span><br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">maxAverageRatio</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; classes, <span class="hljs-type">int</span> extraStudents)</span> </span>&#123;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;&gt; qu; <span class="hljs-comment">// 默认最大堆</span><br>        <br>        <span class="hljs-comment">// 入队列，按照分配1个之后的差值，排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; classes.<span class="hljs-built_in">size</span>(); i++) &#123;            <br>            qu.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">cal</span>(classes[i]), i); <span class="hljs-comment">// !!优先使用emplace/emplace_back， 比push/push_back更高效</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (extraStudents--) &#123;<br>            <span class="hljs-keyword">auto</span> [diff, i] = qu.<span class="hljs-built_in">top</span>();<br>            qu.<span class="hljs-built_in">pop</span>();<br>            <br>            <br>            <span class="hljs-comment">// 从队列中取出差值最大的一项，即分配给它后结果最大的</span><br>            classes[i][<span class="hljs-number">0</span>]++;<br>            classes[i][<span class="hljs-number">1</span>]++;<br>            <br>            <span class="hljs-comment">// 分配后重新塞回队列</span><br>            qu.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">cal</span>(classes[i]), i&#125;);<br>        &#125;<br>        <br>        <span class="hljs-keyword">auto</span> maxsum = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : classes) &#123;           <br>            <span class="hljs-comment">//cout &lt;&lt; cal(c) &lt;&lt; &quot;-&quot; &lt;&lt; c[0] &lt;&lt; &quot;-&quot; &lt;&lt; c[1] &lt;&lt; endl;</span><br>            maxsum += (<span class="hljs-type">double</span>)c[<span class="hljs-number">0</span>] / c[<span class="hljs-number">1</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxsum / classes.<span class="hljs-built_in">size</span>();<br>    &#125;    <br>&#125;;<br></code></pre></td></tr></table></figure><p>⚠ <strong>Note</strong>: 转载请注明出处</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
