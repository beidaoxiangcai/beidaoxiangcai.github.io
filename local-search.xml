<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello Hexo</title>
    <link href="/2023/03/04/Hello-Hexo/"/>
    <url>/2023/03/04/Hello-Hexo/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/04/hello-world/"/>
    <url>/2023/03/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/08/leetcode/STL/"/>
    <url>/2021/09/08/leetcode/STL/</url>
    
    <content type="html"><![CDATA[<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// lambda </span><br><span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;iter1, <span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;iter2) &#123;<br>    <span class="hljs-keyword">return</span> iter1 &gt; iter2;<br>&#125;);<br><br><br><span class="hljs-comment">// operator() </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">IntCompareClass</span>&#123;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; elem1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; elem2)</span></span>&#123;<br><span class="hljs-keyword">return</span> elem1 &gt; elem2;<br>&#125;<br>&#125; IntObjectCom;<br><span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>(), IntObjectCom);<br></code></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">islower/isupper<br>isalpha<br>isdigit 是否是十进制数字<br>isalnum 是否数字或字母<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/08/leetcode/%E7%AE%97%E6%B3%95%E8%AF%8D%E6%B1%87/"/>
    <url>/2021/09/08/leetcode/%E7%AE%97%E6%B3%95%E8%AF%8D%E6%B1%87/</url>
    
    <content type="html"><![CDATA[<h2 id="算法词汇"><a href="#算法词汇" class="headerlink" title="算法词汇"></a>算法词汇</h2><ul><li><p>anagram 相同字母异序词</p></li><li><p>palindrome 回文</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/08/23/leetcode/dfs/"/>
    <url>/2021/08/23/leetcode/dfs/</url>
    
    <content type="html"><![CDATA[<p>DFS template</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    stack&lt;TreeNode*&gt; stack;<br>    <br>    stack.<span class="hljs-built_in">emplace</span>(root); <span class="hljs-comment">// root could be null</span><br>    <span class="hljs-keyword">while</span>(!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> node = stack.<span class="hljs-built_in">top</span>();<br>        stack.<span class="hljs-built_in">pop</span>();<br>                    <br>        <span class="hljs-keyword">if</span> (node) &#123;<br>            stack.<span class="hljs-built_in">emplace</span>(node-&gt;left);<br>            stack.<span class="hljs-built_in">emplace</span>(node-&gt;right);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>变种1 【leetcode653】， 当为BST时，找两个节点值的和为指定K值时， 通过边dfs边记录节点值的方式，实现O(n) 找到两个目标节点</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shell语法总结</title>
    <link href="/2021/03/14/shell%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/03/14/shell%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Shell语法"><a href="#Shell语法" class="headerlink" title="Shell语法"></a>Shell语法</h2><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><ul><li><code>./aa.sh</code><ul><li>打开一个<strong>subshell</strong>去读取、执行aa.sh，而aa.sh<strong>需要有执行权限</strong></li><li>依赖首行明确解释器类型，否则就不在subshell中执行</li><li>通知系统在当前目录找aa.sh,而直接执行aa.sh&#96;，linux 系统将在 PATH里的目录里找aa.sh</li></ul></li><li><code>sh/bash aa.sh</code>  <ul><li>打开一个<strong>subshell</strong>运行解释器去读取、执行aa.sh，文件名作为参数，<strong>无需执行权限</strong></li><li>无需在首行写类似<code>#!/bin/bash*</code>来明确解释器</li></ul></li><li><code>source aa.sh</code><ul><li><strong>当前shell内</strong>读取、执行aa.sh，会保留和改变当前shell中的变量，<strong>无需执行权限</strong></li><li>soure可以简化为点号”.”，推荐点号</li></ul></li></ul><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><p>$aa与${aa}没有区别，但是{}可以用来明确变量边界，同时支持拼接</p></li><li><p><code>readonly aa</code> 设置变量aa为只读</p></li><li><p><code>unset aa</code> 删除变量aa, 不能删只读变量</p></li><li><p>shell变量</p><ul><li>&#96;&#96;&#96;<br>$$ &#x2F;&#x2F; shell本身PID<br>$* $@  参数列表（不包括脚本文件名）<br>$# 参数列表中参数个数<br>$0 脚本文件名<br>$n 第n个参数<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>#### 字符串<br><br>+ 单引号里的任何字符都会原样输出，因而变量是无效的<br>+ 字符串长度 `$&#123;#string&#125;`<br>+ 截取子串 `$&#123;string:<span class="hljs-number">1</span>:<span class="hljs-number">4</span>&#125;` 截取string位置<span class="hljs-number">1</span>开始的<span class="hljs-number">4</span>个字符<br><br>#### 数组<br><br>```shell<br>array_name=(value0 value1 value2 value3) #不限定长度，下标从<span class="hljs-number">0</span>开始，空格分割<br>array_name[n]=valuen <br>$&#123;array_name[@]&#125; # 使用 @ 符号可以获取数组中的所有元素<br>length=$&#123;#array_name[@]&#125; # 取得数组元素的个数<br>lengthn=$&#123;#array_name[n]&#125; # 取得数组单个元素的长度<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h4><ul><li>&#96;&#96;&#96;shell<br>: &lt;&lt;’COMMENT’<br>something<br>COMMENT<br>或者<br>: &lt;&lt;!<br>something<br>!<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br><span class="hljs-comment">#### Shell编码</span><br><br><span class="hljs-comment">#### cd安全</span><br><br>+ cd可能由于错误路径、无权限等问题而失败，一旦失败后续操作将在错误目录上继续执行，引发误操作。<br>+ 通过添加错误判断并<span class="hljs-keyword">exit</span>方式避免错误操作。<br><br>```shell<br>cd foo || <span class="hljs-keyword">exit</span> <span class="hljs-regexp">//</span> <span class="hljs-keyword">exit</span>返回cd错误码<br>cd foo || &#123; echo <span class="hljs-string">&quot;Failure&quot;</span>; <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>; &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>进入当前脚本路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">(<span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(dirname $0)</span>&quot;</span>;<span class="hljs-built_in">pwd</span>)</span><br></code></pre></td></tr></table></figure><p>进入当前函数执行路径，如脚本A调用脚本B，在B中执行则得到B的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">( <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$( dirname <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;BASH_SOURCE[0]&#125;</span>&quot;</span> )</span>&quot;</span> &amp;&amp; <span class="hljs-built_in">pwd</span> )</span><br></code></pre></td></tr></table></figure><h2 id="静波代码检视"><a href="#静波代码检视" class="headerlink" title="静波代码检视"></a>静波代码检视</h2><h4 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a>离线检测</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">apt-get install shellcheck<br>shellcheck file.sh<br></code></pre></td></tr></table></figure><h4 id="在线检测"><a href="#在线检测" class="headerlink" title="在线检测"></a>在线检测</h4><ul><li><p>在线检测<a href="https://www.shellcheck.net/%EF%BC%8C%E8%B4%B4%E5%85%A5%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B">https://www.shellcheck.net/，贴入代码，自动检测</a></p></li><li><p>注意加上 <code>#!/bin/bash</code>，否则报错</p></li></ul><p><img src="/img/shell-check.png" alt="shellcheck示意"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高频VIM命令</title>
    <link href="/2021/03/14/%E9%AB%98%E9%A2%91VIM%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/03/14/%E9%AB%98%E9%A2%91VIM%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="VIM命令"><a href="#VIM命令" class="headerlink" title="VIM命令"></a>VIM命令</h2><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul><li>normal模式下用&#x2F;</li><li>用n查找下一个，N查找上一个</li><li>尾部加\c表示大小写不敏感，\C敏感，如&#x2F;foll\C</li><li>按下*，可查找光标所在单词（前后有空白），g*则可查光标所在字符序列</li></ul><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><ul><li>&#96;&#96;&#96;<br>:{作用范围}s&#x2F;{目标}&#x2F;{替换}&#x2F;{替换标志}<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><br>+ ```<br>  <span class="hljs-symbol">:%s/foo/bar/gc</span> <br>  <span class="hljs-comment"># %表示作用全文</span><br>  替换标志中g表示替换所有，没有表示只替换第一个<br>  替换标志中c表示需确认<br></code></pre></td></tr></table></figure></li></ul><h4 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h4><ul><li><p><strong>从windows复制到vim</strong>，需先按a&#x2F;i&#x2F;insert键进入插入模式，再右键粘贴，否则在命令模式下将识别为vim命令直至遇到i&#x2F;a</p></li><li><p><strong>复制选中区</strong>，光标在复制开始地方按v进入可视模式，结束地方按y复制，直待粘贴处按p粘贴</p></li><li><p>复制整行，yy</p></li><li><p>剪切整行，dd</p></li><li><p>粘贴,p， 粘贴在光标前为P</p></li></ul><h4 id="光标跳转"><a href="#光标跳转" class="headerlink" title="光标跳转"></a>光标跳转</h4><ul><li>文件首： gg</li><li>文件尾： shift + g</li><li>文件指定行： 行号（命令行模式）</li><li>行首： home键</li><li>行尾： end键</li></ul><h4 id="查历史命令"><a href="#查历史命令" class="headerlink" title="查历史命令"></a>查历史命令</h4><p>窗口中ctrl + R，输入关键词如<code>git commit</code>，将出现以该关键词为首的历史命令，通过多次ctrl + R来选择切换历史命令，然后通过右箭头选中命令</p><p><img src="/img/linux-cmd.png" alt="历史命令"></p><h4 id="tab设置"><a href="#tab设置" class="headerlink" title="tab设置"></a>tab设置</h4><ul><li><p>显示tab  命令模式下<code>set list</code></p></li><li><p>设置tab为4空格，且自动缩进， &#x2F;etc&#x2F;vimrc中添加</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">ts</span>=4<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">softtabstop</span>=4<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">shiftwidth</span>=4<br><span class="hljs-built_in">set</span> expandtab<br><span class="hljs-built_in">set</span> autoindent<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>algoexpert笔记</title>
    <link href="/2021/03/14/algoexpert%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/14/algoexpert%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="algoexpert笔记"><a href="#algoexpert笔记" class="headerlink" title="algoexpert笔记"></a>algoexpert笔记</h2><h2 id="英语术语"><a href="#英语术语" class="headerlink" title="英语术语"></a>英语术语</h2><p>tackle</p><p>canical system design 典型系统设计</p><p>intentionaly vague 刻意模糊</p><p>be stated in a few words</p><p>nuance 细微差别</p><p>redundancy 冗余性</p><p>be well versed in 精通</p><p>trade off  交换东西，交易</p><p>througput 流量</p><p>a <strong>0-indexed</strong> array <code>nums</code> of <strong>distinct</strong> integers  以0为起始索引的互不相等的数组</p><p>东方闪电</p>]]></content>
    
    
    
    <tags>
      
      <tag>system design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ std::priority_queue优先队列详解</title>
    <link href="/2021/03/14/C-std-priority-queue%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/03/14/C-std-priority-queue%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="STL-priority-queue优先队列"><a href="#STL-priority-queue优先队列" class="headerlink" title="STL priority_queue优先队列"></a>STL priority_queue优先队列</h2><p>优先队列是一种容器适配器，队列元素要求实现了严格弱排序（Strict Weak Ordering），保证队列顶点（top）元素始终为最大值（最小值）。</p><p>优先队列本质上是一种堆，默认最大堆，即每一个父节点的值都比其子节点要大，因此根节点中的元素总是树中的最大值，因此常用于最值的读取。在时间复杂度上，优先队列实现单个元素的增删都是O(log n)，而读取队列顶点则为O(1)</p><h2 id="接口原型-🔎"><a href="#接口原型-🔎" class="headerlink" title="接口原型 🔎"></a>接口原型 🔎</h2><p>如下接口定义可以看出，优先队列的定义包含三个元素：</p><ul><li>元素类型T；</li><li>存储元素的基础容器类型，要求为拥有连续内存分布的<a href="https://en.cppreference.com/w/cpp/named_req/SequenceContainer">SequenceContainer</a>， STL中满足的就是std::vector and std::deque两种了；</li><li>元素比较函数Compare， Compare函数主要用于元素比较，实现严格的弱排序，由于排序，优先队列已经不满足“先进先出”的特性了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span> = vector&lt;T&gt;,<br>  <span class="hljs-keyword">class</span> Compare = less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt; &gt; <span class="hljs-keyword">class</span> priority_queue;<br></code></pre></td></tr></table></figure><h2 id="主要成员函数"><a href="#主要成员函数" class="headerlink" title="主要成员函数"></a>主要成员函数</h2><p>所有STL标准库实现的数据结构，都有对应的CRUD（增删改查）接口，形式也基本类似.</p><p><img src="/img/priority_queues_feat.png" alt="优先队列出入示意图"></p><p><img src="/img/priority_queue_member_function.png" alt="成员函数详解表"></p><h2 id="Comp函数"><a href="#Comp函数" class="headerlink" title="Comp函数"></a><strong>Comp函数</strong></h2><p>comp函数默认为使用仿函数<code>std::less&lt;int&gt;</code>,表示最大堆 ，这里less是降序，但由于优先队列将top指向了队列尾；同理，<code>std::greater&lt;T&gt;</code>,表示最小堆.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Compare</span> = less&lt;<span class="hljs-keyword">typename</span> Container::value_type&gt; <br></code></pre></td></tr></table></figure><p>comp函数要求严格弱排序，那么什么是严格弱排序</p><p>维基百科给出了如下定义，简言之就是内置类型会通过<code>!(a &lt; b) &amp;&amp; !( b &lt; a ) </code>来判断ab是否相等，如果判断中携带了<code>=</code>如<code>&gt;=</code>、<code>&lt;=</code>，将导致相等判断逻辑出现错误。</p><blockquote><p>A Strict Weak Ordering is a Binary Predicate that compares two objects, returning true if the first precedes the second. This predicate must satisfy the standard mathematical definition of a strict weak ordering. The precise requirements are stated below, but what they roughly mean is that a Strict Weak Ordering has to behave the way that “less than” behaves: if a is less than b then b is not less than a, if a is less than b and b is less than c then a is less than c, and so on.</p></blockquote><p>另外当元素类型T为自定义类型时，那就需要自定义的comp函数，一般有实现后缀运算<code>()</code>函数 和 重载关系运算符 <code>&lt;</code>、 <code>&gt;</code> 两种方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span> <span class="hljs-comment">// priority_queue头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span> <span class="hljs-comment">// 仿函数头文件</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-type">int</span> x, y; <br><span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125; <br>&#125;;<br> <br><span class="hljs-comment">// &lt;操作符用于仿函数std::less</span><br><span class="hljs-comment">// node比较先按照x降序，x相等时，再按照y降序</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (Node a, Node b) <br>&#123; <br>      <span class="hljs-keyword">if</span> (a.x &gt; b.x) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.x == b.x) &#123;<br><span class="hljs-keyword">return</span> a.y &gt; b.y; <span class="hljs-comment">// 严格弱排序</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;      <br>&#125;<br><br>std::priority_queue&lt;Node, std::vector&lt;Node&gt;, std::less&lt;Node&gt;&gt; pq; <span class="hljs-comment">// 大顶堆</span><br><br><span class="hljs-comment">// &gt;操作符用于仿函数std::greater</span><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt; (Node a, Node b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a.x&gt; b.x;<br>&#125;<br><br>std::priority_queue&lt;Node, std::vector&lt;Node&gt;, std::greater&lt;Node&gt;&gt; pq; <span class="hljs-comment">// 小顶堆</span><br><br><span class="hljs-comment">// 自定义后缀操作符</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Node a,Node b)</span></span><br><span class="hljs-function">    </span>&#123;<br>  <span class="hljs-keyword">return</span> a.x &gt; b.x;<br>    &#125;<br>&#125;;<br><br>std::priority_queue&lt;Node, std::vector&lt;Node&gt;, cmp&gt; pq;<br><br></code></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>优先队列作为数据结构中堆的一种具体实现，在leetcode算法题中出现频率较高。比如这题<a href="https://leetcode.com/problems/maximum-average-pass-ratio/">leetcode 1792. Maximum Average Pass Ratio</a></p><p>在如下解答中，可以发现priority_queue的几个关键接口的使用。</p><p>另外算法层面可以看到，通过对优先队列进行增删读元素，使得每次都对最值进行操作，也就保证了每次操作都为最优解。实际上这就是<strong>贪心算法，通过求解每个子问题的最优解，来得到整个问题的最终最优解</strong>。也正因如此，优先队列就常在一些有约束条件下的分配问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// !!整数除法一定先转double, 注意检查括号</span><br>    <span class="hljs-comment">// !!乘法注意溢出，少量的除法误差可以容忍</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> cal(xy) ((double)(xy[0] +1) / (xy[1] + 1) - (double)(xy[0]) / (xy[1]))</span><br><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">maxAverageRatio</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; classes, <span class="hljs-type">int</span> extraStudents)</span> </span>&#123;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt;&gt; qu; <span class="hljs-comment">// 默认最大堆</span><br>        <br>        <span class="hljs-comment">// 入队列，按照分配1个之后的差值，排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; classes.<span class="hljs-built_in">size</span>(); i++) &#123;            <br>            qu.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">cal</span>(classes[i]), i); <span class="hljs-comment">// !!优先使用emplace/emplace_back， 比push/push_back更高效</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">while</span> (extraStudents--) &#123;<br>            <span class="hljs-keyword">auto</span> [diff, i] = qu.<span class="hljs-built_in">top</span>();<br>            qu.<span class="hljs-built_in">pop</span>();<br>            <br>            <br>            <span class="hljs-comment">// 从队列中取出差值最大的一项，即分配给它后结果最大的</span><br>            classes[i][<span class="hljs-number">0</span>]++;<br>            classes[i][<span class="hljs-number">1</span>]++;<br>            <br>            <span class="hljs-comment">// 分配后重新塞回队列</span><br>            qu.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-built_in">cal</span>(classes[i]), i&#125;);<br>        &#125;<br>        <br>        <span class="hljs-keyword">auto</span> maxsum = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : classes) &#123;           <br>            <span class="hljs-comment">//cout &lt;&lt; cal(c) &lt;&lt; &quot;-&quot; &lt;&lt; c[0] &lt;&lt; &quot;-&quot; &lt;&lt; c[1] &lt;&lt; endl;</span><br>            maxsum += (<span class="hljs-type">double</span>)c[<span class="hljs-number">0</span>] / c[<span class="hljs-number">1</span>];<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> maxsum / classes.<span class="hljs-built_in">size</span>();<br>    &#125;    <br>&#125;;<br></code></pre></td></tr></table></figure><p>⚠ <strong>Note</strong>: 转载请注明出处</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>math</title>
    <link href="/2021/03/14/leetcode/math/"/>
    <url>/2021/03/14/leetcode/math/</url>
    
    <content type="html"><![CDATA[<h2 id="指数POW函数"><a href="#指数POW函数" class="headerlink" title="指数POW函数"></a>指数POW函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> num, <span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-comment">// 要求num &gt; 0, 0 &lt;= p &lt;= 64</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ret = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> MOD = <span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, index = <span class="hljs-number">1</span>, tt = num % MOD; i &lt; <span class="hljs-number">64</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (p &amp; index) &#123;<br>                ret = (ret * tt) % MOD;<br>            &#125;<br>            <br>            tt = (tt * tt) % MOD;<br>            index &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>system design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言中channel的常见用法</title>
    <link href="/2019/02/28/Go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/"/>
    <url>/2019/02/28/Go%E8%AF%AD%E8%A8%80%E4%B8%ADchannel%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="channel基本用法"><a href="#channel基本用法" class="headerlink" title="channel基本用法"></a>channel基本用法</h2><h2 id="channel骚操作"><a href="#channel骚操作" class="headerlink" title="channel骚操作"></a>channel骚操作</h2><h4 id="校验channel是否关闭"><a href="#校验channel是否关闭" class="headerlink" title="校验channel是否关闭"></a>校验channel是否关闭</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> v, ok := &lt;- ch; ok &#123;<br>    fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="控制函数并发度"><a href="#控制函数并发度" class="headerlink" title="控制函数并发度"></a>控制函数并发度</h4><p>如下函数test在多个线程中运行，但同时并发只能有5个实例，如在redis 连接池的处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>    ch &lt;- <span class="hljs-string">&quot;test start&quot;</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        &lt;-ch<br>    &#125;<br>    <span class="hljs-comment">// do something</span><br>    ... <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="！未完待续"><a href="#！未完待续" class="headerlink" title="！未完待续"></a>！未完待续</h3>]]></content>
    
    
    
    <tags>
      
      <tag>K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8S informer机制与使用</title>
    <link href="/2019/02/28/k8s%20informer%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/02/28/k8s%20informer%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
    
    
    
    <tags>
      
      <tag>K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes Pod知识图谱</title>
    <link href="/2019/02/28/k8s%20pod%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    <url>/2019/02/28/k8s%20pod%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/k8s-pod.svg" alt="k8s-pod"></p><blockquote><p>参考 <em>《kubernetes 权威指南》</em></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用操作总结</title>
    <link href="/2017/02/28/2020-12-10-git%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2017/02/28/2020-12-10-git%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="批量删除Git分支"><a href="#批量删除Git分支" class="headerlink" title="批量删除Git分支"></a>批量删除Git分支</h2><h3 id="删本地分支"><a href="#删本地分支" class="headerlink" title="删本地分支"></a>删本地分支</h3><p>git branch 输出分支列表， 通过管道过滤出包含关键词 keyname分支名的分支，传递给git branch -D 本地分支强制删除命令中，实现<strong>批量删除包含keyname字符串的本地分支</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">git branch |<span class="hljs-type">grep</span> &#x27;keyname&#x27; | <span class="hljs-type">xargs</span> git branch -D<br></code></pre></td></tr></table></figure><h4 id="删远程分支"><a href="#删远程分支" class="headerlink" title="删远程分支"></a>删远程分支</h4><p>git branch 输出分支列表， 通过管道过滤出包含关键词 keyname分支名的分支，传递给git push origin –delete 远端分支强制删除命令中，实现<strong>批量删除包含keyname字符串的远端分支</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">git branch |<span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;keyname&#x27;</span> | xargs git <span class="hljs-keyword">push</span> origin --<span class="hljs-keyword">delete</span><br></code></pre></td></tr></table></figure><h2 id="误删分支找回"><a href="#误删分支找回" class="headerlink" title="误删分支找回"></a>误删分支找回</h2><p>git reflog查看所有分支的commit记录,根据commit记录创建分支</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">git branch <span class="hljs-keyword">new</span><span class="hljs-type">BranchName</span> HEAD@&#123;**&#125;<br></code></pre></td></tr></table></figure><p>切换到新分支后，push到远端即可恢复远端分支</p><p><img src="/img/findback-branch.png" alt="找回分支"></p><h2 id="Git快捷命令配置（别名）"><a href="#Git快捷命令配置（别名）" class="headerlink" title="Git快捷命令配置（别名）"></a>Git快捷命令配置（别名）</h2><p>git bash窗口中vi &#x2F;etc&#x2F;bash.bashrc，在尾部添加如下代码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">alias <span class="hljs-attribute">gst</span>=<span class="hljs-string">&#x27;git status&#x27;</span><br>alias <span class="hljs-attribute">gdiff</span>=<span class="hljs-string">&#x27;git diff&#x27;</span><br>alias <span class="hljs-attribute">gadd</span>=<span class="hljs-string">&#x27;git add&#x27;</span><br>alias <span class="hljs-attribute">gci</span>=<span class="hljs-string">&#x27;git commit -m &quot;hello world&quot;&#x27;</span><br>alias <span class="hljs-attribute">gthis</span>=<span class="hljs-string">&#x27;git rev-parse --abbrev-ref HEAD&#x27;</span><br>alias <span class="hljs-attribute">gpush</span>=<span class="hljs-string">&#x27;git push origin `gthis`&#x27;</span><br>alias <span class="hljs-attribute">gco</span>=<span class="hljs-string">&#x27;git checkout&#x27;</span><br>alias <span class="hljs-attribute">gbr</span>=<span class="hljs-string">&#x27;git branch&#x27;</span><br>alias <span class="hljs-attribute">gname</span>=<span class="hljs-string">&#x27;vi /etc/bash.bashrc&#x27;</span><br></code></pre></td></tr></table></figure><p>保存后重启bash窗口，生效快捷命令映射</p><p>若保存时，遇到[&#x2F;etc&#x2F;bashrc Permission denied，则用管理员权限打开git bash重试即可</p><p><img src="/img/bash-run.png" alt="管理员权限运行bash"></p><h2 id="记录Git用户名密码"><a href="#记录Git用户名密码" class="headerlink" title="记录Git用户名密码"></a>记录Git用户名密码</h2><p>git 默认每次pull等操作时要求输入密码，比较麻烦，可通过如下命令永久保存密码，再输入一次后就无需输入了。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">git config credential.helper store<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
